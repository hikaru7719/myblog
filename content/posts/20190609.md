---
title: "SQLのパフォーマンスについて"
date: 2019-06-08T15:31:57+09:00
draft: true
---

# SQLパフォーマンス詳解を読んだ
[SQLパフォーマンス詳解   Markus Winand ](https://www.amazon.co.jp/dp/3950307842/ref=cm_sw_r_tw_dp_U_x_XA1-CbF6D47V9)
SQLについてあまり知識がなかったので、勉強しようと思いこの本を読みました。
この本ではSQLのインデックスをどのように作成するのが良いのかについて書かれています。
この本を読んで色々学ぶことができたのでアウトプットとしてブログを書きたいと思います。

## インデックスとは
インデックスとはその名のとおり索引のことです。
私たちが辞書を引く際に、調べたい文字の先頭の文字でまず大きな当たりをつけて、そこから調べたい文字をたどっていくとということをします。SQLのインデックスを同様です。

インデックスとは基本的にはソートされた木構造です。より詳細に言うとインデックスはB木構造をしています。

子のノードの最大値を集めたものが次のノードになります。
今回の図ではリーフノードの[30,31,33]のブロックの最大値の33,[45,47,48]のブロックの最大値の48,[49,50,53]のブロックの最大値の53,[54,55,56]のブロックの最大値の56が次のノードの要素になっています。この操作を親ノードが１つになるまで繰り返したものがB木構造です。
![](/B-tree.jpeg)

SQLのインデックスはこのような構造をしており、リーフノードはデータへのポインタを持っています。
例えばこの図の49,50,53がレコードのIDでそれ以外の属性をたどるにはリーフノードのポインタをたどって取得します。

辞書の索引と同じようにソートされていることによってSQLは効率的に目的のデータにたどり着くことができます。

## MySQLでのインデックス
インデックスの効果を体感するために実際に手を動かしてみます。
テーブルのプライマリキーはインデックスを明示的に作らなくてもデータベース側で勝手に作ってくれます。
まずはプライマリキーをWhere句に指定したSQLを発行してみます。
今回使うテーブルはmySQLのドキュメントにのっているテストデータです。
テーブルの構造は以下のような形をしています。
![](/table-structure.png)
どうやら従業員のデータのようです。
emp_noがPRIMARY_KEYなのでこれに対してインデックスが貼られています。
ちなみにemployeesテーブルには300024人の従業員データが入っています。

