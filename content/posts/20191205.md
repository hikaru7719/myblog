---
title: "aws-cdkを使ってECS(Fargate起動タイプ)を構築する"
date: 2019-12-04T20:16:36+09:00
draft: true
---

この記事はTypeScript Advent Calender 5日目の記事です。
さて、AWS CDKがGAになり、半年くらい経ちました。
AWS EKS on AWS Fargateが発表され、かなり熱いFargateですが、今回の記事ではFargate起動タイプのECSをAWS CDKを利用して、構築したいと思います。

もちろんTypeScriptのアドベントカレンダーなので、TypeScript版AWS CDKを利用します。
現在ではPythonやJava,.NETなど様々な言語でAWS CDKが使えるようです。

## AWS CDK
AWS CDKはインフラ構築のためのツールで、インフラをアプリケーションコードを書くように定義できます。
AWS CDKのコードを実行すると、Cloud Formationテンプレートが生成され、CloudFormationを通して実行されます。
AWS CDKはCloud Formationテンプレートを直接記述するより少ないコード量で記述できます。少ないコード量でCloudFormationを記述できる理由としては以下の点が挙げられます。

- 多くの値にデフォルト値が設定されている
- 抽象度の高い関数がある

例えばLamabdaとAPI Gatewayの組み合わせは以下のようなコードで実現できます。

```
import * as cdk from "@aws-cdk/core";
import * as lambda from "@aws-cdk/aws-lambda";
import * as apigw from "@aws-cdk/aws-apigateway";

export class CdkWorkshopStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // defines an AWS Lambda resource
    const hello = new lambda.Function(this, 'HelloHandler', {
      runtime: lambda.Runtime.NODEJS_8_10,      // execution environment
      code: lambda.Code.asset('lambda'),  // code loaded from the "lambda" directory
      handler: 'hello.handler'                // file is "hello", function is "handler"
    });

    // defines an API Gateway REST API resource backed by our "hello" function.
    new apigw.LambdaRestApi(this, 'Endpoint', {
      handler: hello
    });

  }
}
```

上の例ではAPI Gatewayにリクエストが来たら、Lambdaを実行するといったインフラを定義しています。上記のコードには一切、IAMの話は書かれていませんが、裏側ではIAM Roleが作成されています。
API GatewayからLambdaの実行を可能にするIAM Roleが作成されています。

このコードからCloudFormationテンプレートを出力するにはcdk synthコマンドを実行します。
CDKの基礎について知りたいかたは一度AWS公式のワークショップを実施することをお勧めします。
https://cdkworkshop.com/

## ECS（Fargate起動タイプ）構築
今回はExpressで書かれたHelloWorldのアプリケーションをECSで実行することがゴールです。
今回利用するコードは全てhttps://github.com/hikaru7719/aws-cdk-for-fargateに上がっています。

実行するindex.tsは以下です。

```
import express from "express";
const app = express();

app.get("/", (req: express.Request, res: express.Response) => {
  res.send("Hello World");
});

app.listen(3000);
```

ECSで実行するにはまず、Docker Imageを作成することが必要です。
以下のDockerfileからDocker Imageを作成します。

```
FROM node:12.13.1
WORKDIR /usr/src/app
COPY package*.json ./
RUN yarn install
COPY . .
RUN yarn tsc --project .
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

package.jsonやtsconfig.jsonの設定は上記のリポジトリを参照してください。


では上記のアプリケーションを実行するための、ECSの環境のコードが以下です。

```
import * as cdk from "@aws-cdk/core";
import * as ecs from "@aws-cdk/aws-ecs";
import * as elb from "@aws-cdk/aws-elasticloadbalancingv2";

export class MyStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // ECS クラスタの定義
    const cluster = new ecs.Cluster(this, "SampleCluster", {
      clusterName: "SmapleCluster"
    });

    // ECSタスクの定義
    const taskDefinition = new ecs.FargateTaskDefinition(this, "TaskDef");

    // ECSタスクにコンテナを紐付ける
    const container = taskDefinition.addContainer("DefaultContainer", {
      image: ecs.ContainerImage.fromAsset("../app"),
      memoryLimitMiB: 512,
      cpu: 256
    });

    // protの宣言
    container.addPortMappings({
      containerPort: 3000
    });

    // ECSのサービスの定義
    const ecsService = new ecs.FargateService(this, "Service", {
      cluster,
      taskDefinition,
      desiredCount: 2
    });

    // ロードバランサーの定義
    const lb = new elb.ApplicationLoadBalancer(this, "LB", {
      vpc: cluster.vpc,
      internetFacing: true
    });

    // ロードバランサーのportを定義
    const listener = lb.addListener("Listener", { port: 80 });

    // ロードバランサーのターゲットのECS サービスを定義
    const targetGroup = listener.addTargets("ECS", {
      protocol: elb.ApplicationProtocol.HTTP,
      port: 3000,
      targets: [ecsService]
    });

    // 作成されたロードバランサのDNS名を標準出力に印字
    new cdk.CfnOutput(this, "LoadBalancerDNS", {
      value: lb.loadBalancerDnsName
    });
  }
}

```

コードだけ見ていくとすごく単純なことをやっているように見えますが、裏ではECSが実行できるように、様々なリソース定義が行われています。

上からコードを見ていきます。
ecs.Cluster関数はクラスタの宣言です。この関数の裏側ではECSを実行するための、VPCの作成、サブネットの作成が行われています。
既存のVPCを利用したい場合には第三引数のオプションから渡すことが可能です。
